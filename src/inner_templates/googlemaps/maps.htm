<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Include the CesiumJS JavaScript and CSS files -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.94/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.94/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <script src="jquery-3.6.0.min.js"></script>
  <script src="globals.js"></script>
  <script src="main_ws_manager.js"></script>
  <style>
  canvas{
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
  }
  </style>
</head>
<body>
  <div id="cesiumContainer" style="display: block;
  position: absolute;
  top: 0;
  left: 0;
  border: none;
  width: 100%;
  height: 100%;"></div>
  <script>
    // Your access token can be found at: https://cesium.com/ion/tokens.
    // Replace `your_access_token` with your Cesium ion access token.

    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyMDBiZDVkYy0wNmM1LTRlMzMtOTM4Yi1jYWZjMmM1MmQ1MWIiLCJpZCI6OTY0NDEsImlhdCI6MTY1NDUwNjc0MH0.iOmEZOXN3XKdl7WsUAvPdjf2M_2OVUUtYLD5Lo3UOUQ';

    // Initialize the Cesium Viewer in the HTML element with the `cesiumContainer` ID.
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: Cesium.createWorldTerrain()
    });
    // Add Cesium OSM Buildings, a global 3D buildings layer.
    //const buildingTileset = viewer.scene.primitives.add(Cesium.createOsmBuildings());
	 var center = Cesium.Cartesian3.fromDegrees(10.855092, 44.508273, 180);
	 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
	 viewer.scene.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(Cesium.Math.toRadians(0), -Math.PI/8, 300));
  </script>
 </div>
</body>
  <body>
    <div id="cesiumContainer" class="cesiumContainer"></div>
	 <div><p class="metrics" style="color: #FFFFFF; position: absolute; top: 80px; right: 0;">Speed: --<br>Cadence: --</p></div>
    <script type="text/javascript">
    let cameraComplete = true
    let lastAzimuth = 0
    let lastAlt = 0
    let lastLat = 0
    let lastLon = 0
    let refreshRate = 25
    let currentSpeed = 0
    let lastCoordinateTS = 0

    function a() {
    onWorkout = false;
    let el = new MainWSQueueElement({
        msg: 'getlatlon'
    }, function(msg) {
        if (msg.msg === 'R_getlatlon') {
            return msg.content;
        }
        return null;
    }, 15000, 3);
    el.enqueue().then(process_latlon).catch(function(err) {
        console.error('Error is ' + err);
    });
    keys_arr = ['speed', 'cadence', 'heart', 'calories', 'distance', 'watts', 'elapsed_h', 'elapsed_m', 'elapsed_s', 'inclination', 'resistance', 'elevation']
         let ell = new MainWSQueueElement({
	     msg: null,
		}, function(msg) {
		  if (msg.msg === 'workout') {
		      var speed = 0;
				var cadence = 0;
				var hr = 0;
				var calories = 0;
				var odometer = 0;
				var watt = 0;
				var elapsed_h = 0;
				var elapsed_m = 0;
				var elapsed_s = 0;
				var inclination = 0;
				var resistance = 0;
				var elevation = 0;
				for (let key of keys_arr) {
				    if (msg.content[key] === undefined)
                                             continue;
						if (key === 'speed') {
                                                  currentSpeed = speed = msg.content[key];
						} else if (key === 'cadence') {
						  cadence = msg.content[key];
						} else if (key === 'heart') {
                                                  hr = msg.content[key];
						} else if (key === 'calories') {
                                                  calories = msg.content[key];
						} else if (key === 'distance') {
                                                  odometer = msg.content[key];
						} else if (key === 'watts') {
                                                  watt = msg.content[key];
						} else if (key === 'elapsed_h') {
                                                  elapsed_h = msg.content[key];
						} else if (key === 'elapsed_m') {
                                                  elapsed_m = msg.content[key];
						} else if (key === 'elapsed_s') {
                                                  elapsed_s = msg.content[key];
						} else if (key === 'inclination') {
                                                  inclination = msg.content[key];
						} else if (key === 'resistance') {
                                                  resistance = msg.content[key];
						} else if (key === 'elevation') {
                                                  elevation = msg.content[key];
						}
				}

            $('.metrics').html("üèÉSpeed: " + speed.toFixed(2) + "<br>üö¥Cadence:" + cadence.toFixed(0) + "<br>üíìHeart:"+ hr.toFixed(0) + "<br>üî•Calories:"+ calories.toFixed(1) + "<br>üìèOdometer:"+ odometer.toFixed(2) + "<br>‚ö°Watt:"+ watt.toFixed(0) + "<br>‚è≤Ô∏èElapsed:"+ elapsed_h.toString().padStart(2, "0") + ":" + elapsed_m.toString().padStart(2, "0") + ":"+ elapsed_s.toString().padStart(2, "0") + "<br>üìêInclination:"+ inclination.toFixed(1) + "<br>üß≤Resistance:"+ resistance.toFixed(0) + "<br>‚õ∞Ô∏èElevation:"+ elevation.toFixed(2));
		  }
		  return null;
		}, 15000, 3);
         ell.enqueue().then(onWorkout).catch(function(err) {
	     console.error('Error is ' + err);
                });
    }

    function camera_complete() {
        cameraComplete = true;
    }

    function easing_function(time) {
        return time;
    }

    function  process_latlon(msg) {
	 /*if(!cameraComplete) return;*/
    cameraComplete = false;
    let lat = parseFloat(msg.split(",")[0]);
    let lon = parseFloat(msg.split(",")[1]);
    let alt = parseFloat(msg.split(",")[2]);
    let azimuth = parseFloat(msg.split(",")[3]);
    if(lastAzimuth != azimuth) {
        if((lastAzimuth > azimuth && Math.abs(lastAzimuth - azimuth) < 180) ||
           (lastAzimuth < azimuth && Math.abs(lastAzimuth - azimuth) > 180)) {
            lastAzimuth = azimuth = lastAzimuth - 0.01;
            if(azimuth < 0)
                lastAzimuth = azimuth = 359.99;
        }
        else {
            lastAzimuth = azimuth = lastAzimuth + 0.01;
            if(azimuth >= 360)
                lastAzimuth = azimuth = 0;
        }
    }
    if(Math.abs(lastAzimuth - azimuth) < 0.01)
        lastAzimuth = azimuth;
    if(lastAlt != alt && Math.abs(lastAlt-alt) < 30) {
        if(lastAlt > alt)
            lastAlt = alt = lastAlt - 0.01;
        else
            lastAlt = alt = lastAlt + 0.01;
    } else {
        lastAlt = alt;
    }
    if(Math.abs(lastAlt - alt) < 0.01)
        lastAlt = alt;

    var p1 = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
    var p2 = Cesium.Cartesian3.fromDegrees(lastLon, lastLat, lastAlt);
    var distance = Cesium.Cartesian3.distance(p1, p2);
    var tick = (Date.now() - lastCoordinateTS)
    let deltaT = (currentSpeed / 3.6) / (1000 / (tick - 1));
    if(distance < 30)
        deltaT = deltaT / 2;
    lastCoordinateTS = Date.now()
    deltaT = distance / deltaT;
    console.log(Date.now() + " distance delta " + distance + " " + tick);
    if(Math.abs(lat - lastLat) > 0.1 || Math.abs(lon - lastLon) > 0.1) {
        lastLat = lat;
        lastLon = lon;
        lastCoordinateTS = Date.now()
    } else if(lat != lastLat || lon != lastLon) {
        if(lat > lastLat) {
            lastLat = lat = lastLat + ((lat-lastLat) / deltaT);
        } else {
            lastLat = lat = lastLat - ((lastLat - lat) / deltaT);
        }
        if(lon > lastLon) {
            lastLon = lon = lastLon + ((lon-lastLon) / deltaT);
        } else {
            lastLon = lon = lastLon - ((lastLon-lon) / deltaT);
        }
    }

    console.log("azimuth " + azimuth + " " + lat + " " + lon);
	 var center = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
	 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
	 viewer.scene.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(Cesium.Math.toRadians(azimuth), -Math.PI/8, 300));
         setTimeout(a,refreshRate);
	 /*
    viewer.camera.flyTo({
      destination : Cesium.Cartesian3.fromDegrees(lon, lat, alt + 60),
      duration: 2,
      orientation : {
        heading : Cesium.Math.toRadians(azimuth),
        pitch : Cesium.Math.toRadians(-5.0),
      },
      easingFunction: easing_function,
      complete: camera_complete
      });*/
                }
					function process_gpxbase64(msg) {
	  viewer.dataSources
	            .add(
					  Cesium.GpxDataSource.load(
                                            msg,
						 {
						   clampToGround: true,
							}
						))
	  }

let el = new MainWSQueueElement({
msg: 'getgpxbase64'
}, function(msg) {
if (msg.msg === 'R_getgpxbase64') {
return msg.content;
}
return null;
}, 15000, 3);
el.enqueue().then(process_gpxbase64).catch(function(err) {
console.error('Error is ' + err);
});
      setTimeout(a,0);
    </script>
  </body>
</html>
