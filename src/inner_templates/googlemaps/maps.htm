<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Include the CesiumJS JavaScript and CSS files -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.94/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.94/Build/Cesium/Widgets/widgets.css" rel="stylesheet">  
  <script src="jquery-3.6.0.min.js"></script>
  <script src="chartjs.3.4.1.min.js"></script>
  <script src="chart.js"></script>
  <script src="globals.js"></script>
  <script src="bike.js"></script>
  <script src="main_ws_manager.js"></script>
  <script src="cesium-key.js"></script>
  <style>
  canvas{
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
  }
  </style>
</head>
<body>
  <div id="cesiumContainer" style="display: block;
  position: absolute;
  top: 0;
  left: 0;
  border: none;
  width: 100%;
  height: 100%;"></div>
  <script>    
    // Initialize the Cesium Viewer in the HTML element with the `cesiumContainer` ID.
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: Cesium.createWorldTerrain()
    });

    $('.cesium-viewer-animationContainer').css("visibility", "hidden");
	 $('.cesium-viewer-bottom').css("visibility", "hidden");
	 $('.cesium-viewer-timelineContainer').css("visibility", "hidden");
	 $('.cesium-viewer-fullscreenContainer').css("visibility", "hidden");


    viewer.scene.globe.enableLighting = true;
	 viewer.scene.fog.enabled = true;
    viewer.scene.globe.depthTestAgainstTerrain = true;
    // Add Cesium OSM Buildings, a global 3D buildings layer.
    //const buildingTileset = viewer.scene.primitives.add(Cesium.createOsmBuildings());
	 var center = Cesium.Cartesian3.fromDegrees(10.855092, 44.508273, 180);
	 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
	 let map = viewer;
	 viewer.scene.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(Cesium.Math.toRadians(0), -Math.PI/8, 100));

var bike = viewer.scene.primitives.add(
   Cesium.ModelExperimental.fromGltf({
	  url: bikeUri,
	  minimumPixelSize: 32,
	  scale: 1,
	  scene : viewer.scene,
	  color: Cesium.Color.ORANGE,
	  silhouetteColor: Cesium.Color.ORANGE,
	  silhouetteSize: 2,
	  })
  );

  </script>
 </div>
</body>
  <body>
    <div id="cesiumContainer" class="cesiumContainer"></div>
	 <div><p class="metrics" style="color: #FFFFFF; position: absolute; top: 80px; right: 0;">Speed: --<br>Cadence: --</p></div>
	 <div style="background-color:white; border: 0px solid #aaa; border-radius: 10px; overflow: hidden; position:absolute; top: 300px; right: 0; width=150px; height=75px">
	    <canvas id="canvasChart" style="width=150px; height=75px"></canvas>
	 </div>
    <script type="text/javascript">
    let cameraComplete = true
    let lastAzimuth = 0
    let lastAlt = 0
    let lastLat = 0
    let lastLon = 0
    let refreshRate = 25
    let currentSpeed = 0
    let lastCoordinateTS = 0
	 let altOffset = 0

    function a() {
    onWorkout = false;
    let el = new MainWSQueueElement({
        msg: 'getlatlon'
    }, function(msg) {
        if (msg.msg === 'R_getlatlon') {
            return msg.content;
        }
        return null;
    }, 15000, 3);
    el.enqueue().then(process_latlon).catch(function(err) {
        console.error('Error is ' + err);
    });
    keys_arr = ['speed', 'cadence', 'heart', 'calories', 'distance', 'watts', 'elapsed_h', 'elapsed_m', 'elapsed_s', 'inclination', 'resistance', 'elevation']
         let ell = new MainWSQueueElement({
	     msg: null,
		}, function(msg) {
		  if (msg.msg === 'workout') {
		      var speed = 0;
				var cadence = 0;
				var hr = 0;
				var calories = 0;
				var odometer = 0;
				var watt = 0;
				var elapsed_h = 0;
				var elapsed_m = 0;
				var elapsed_s = 0;
				var inclination = 0;
				var resistance = 0;
				var elevation = 0;
				var altitude = 0;
				for (let key of keys_arr) {
				    if (msg.content[key] === undefined)
                                             continue;
						if (key === 'speed') {
                                                  currentSpeed = speed = msg.content[key];
						} else if (key === 'cadence') {
						  cadence = msg.content[key];
						} else if (key === 'heart') {
                                                  hr = msg.content[key];
						} else if (key === 'calories') {
                                                  calories = msg.content[key];
						} else if (key === 'distance') {
                                                  odometer = msg.content[key];
						} else if (key === 'watts') {
                                                  watt = msg.content[key];
						} else if (key === 'elapsed_h') {
                                                  elapsed_h = msg.content[key];
						} else if (key === 'elapsed_m') {
                                                  elapsed_m = msg.content[key];
						} else if (key === 'elapsed_s') {
                                                  elapsed_s = msg.content[key];
						} else if (key === 'inclination') {
                                                  inclination = msg.content[key];
						} else if (key === 'resistance') {
                                                  resistance = msg.content[key];
						} else if (key === 'elevation') {
                                                  elevation = msg.content[key];
																} else if (key === 'altitude') {
																  altitude = msg.content[key];
																}
				}

            $('.metrics').html("üèÉSpeed: " + speed.toFixed(2) + "<br>üö¥Cadence:" + cadence.toFixed(0) + "<br>üíìHeart:"+ hr.toFixed(0) + "<br>üî•Calories:"+ calories.toFixed(1) + "<br>üìèOdometer:"+ odometer.toFixed(2) + "<br>‚ö°Watt:"+ watt.toFixed(0) + "<br>‚è≤Ô∏èElapsed:"+ elapsed_h.toString().padStart(2, "0") + ":" + elapsed_m.toString().padStart(2, "0") + ":"+ elapsed_s.toString().padStart(2, "0") + "<br>üìêInclination:"+ inclination.toFixed(1) + "<br>üß≤Resistance:"+ resistance.toFixed(0) + "<br>‚úàÔ∏èAltitude:"+ altitude.toFixed(1) + "<br>‚õ∞Ô∏èElevation:"+ elevation.toFixed(2));
		  }
		  return null;
		}, 15000, 3);
         ell.enqueue().then(onWorkout).catch(function(err) {
	     console.error('Error is ' + err);
                });
    }

    function camera_complete() {
        cameraComplete = true;
    }

    function easing_function(time) {
        return time;
    }

    function  process_latlon(msg) {
	 /*if(!cameraComplete) return;*/
    cameraComplete = false;
    let lat = parseFloat(msg.split(",")[0]);
    let lon = parseFloat(msg.split(",")[1]);
	 let alt = parseFloat(msg.split(",")[2]) + altOffset;
    let azimuth = parseFloat(msg.split(",")[3]);
    if(lastAzimuth != azimuth) {
        if((lastAzimuth > azimuth && Math.abs(lastAzimuth - azimuth) < 180) ||
           (lastAzimuth < azimuth && Math.abs(lastAzimuth - azimuth) > 180)) {
            lastAzimuth = azimuth = lastAzimuth - 0.01;
            if(azimuth < 0)
                lastAzimuth = azimuth = 359.99;
        }
        else {
            lastAzimuth = azimuth = lastAzimuth + 0.01;
            if(azimuth >= 360)
                lastAzimuth = azimuth = 0;
        }
    }
    if(Math.abs(lastAzimuth - azimuth) < 0.01)
        lastAzimuth = azimuth;
    if(lastAlt != alt && Math.abs(lastAlt-alt) < 30) {
        if(lastAlt > alt)
            lastAlt = alt = lastAlt - 0.01;
        else
            lastAlt = alt = lastAlt + 0.01;
    } else {
        lastAlt = alt;
    }
    if(Math.abs(lastAlt - alt) < 0.01)
        lastAlt = alt;

    var p1 = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
    var p2 = Cesium.Cartesian3.fromDegrees(lastLon, lastLat, lastAlt);
    var distance = Cesium.Cartesian3.distance(p1, p2);
    var tick = (Date.now() - lastCoordinateTS)
    let deltaT = (currentSpeed / 3.6) / (1000 / (tick - 1));
    if(distance < 30)
        deltaT = deltaT / 2;
    lastCoordinateTS = Date.now()
    deltaT = distance / deltaT;
    console.log(Date.now() + " distance delta " + distance + " " + tick);
    if(Math.abs(lat - lastLat) > 0.1 || Math.abs(lon - lastLon) > 0.1) {
        lastLat = lat;
        lastLon = lon;
        lastCoordinateTS = Date.now()
    } else if(lat != lastLat || lon != lastLon) {
        if(lat > lastLat) {
            lastLat = lat = lastLat + ((lat-lastLat) / deltaT);
        } else {
            lastLat = lat = lastLat - ((lastLat - lat) / deltaT);
        }
        if(lon > lastLon) {
            lastLon = lon = lastLon + ((lon-lastLon) / deltaT);
        } else {
            lastLon = lon = lastLon - ((lastLon-lon) / deltaT);
        }
    }

    console.log("azimuth " + azimuth + " " + lat + " " + lon);
	 var center = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
	 var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
	 viewer.scene.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(Cesium.Math.toRadians(azimuth), -Math.PI/8, 300));

   const length = 2;

   const startLon = Cesium.Math.toRadians(lon);
	const endLon = Cesium.Math.toRadians(lon + 0.000001);

   const startLat = Cesium.Math.toRadians(lat);

   const terrainSamplePositions = [];
	for (let i = 0; i < length; ++i) {
	  const lonL = Cesium.Math.lerp(
	    endLon,
		 startLon,
		 i / (length - 1)
	  );
	  const position = new Cesium.Cartographic(lonL, startLat);
	  terrainSamplePositions.push(position);
	  }

   Promise.resolve(
	  Cesium.sampleTerrainMostDetailed(
	    viewer.terrainProvider,
		 terrainSamplePositions
	  )
	  ).then(function (samples) {
	  const hpr = new Cesium.HeadingPitchRoll(
	    Cesium.Math.toRadians(azimuth),
		 0,
		 0
	  );
	      bike.modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(Cesium.Cartesian3.fromDegrees(lon, lat, samples[0].height), hpr);
	  });

const startLonCamera = Cesium.Math.toRadians(Cesium.Math.toDegrees(viewer.scene.camera.positionCartographic.longitude));
const endLonCamera = Cesium.Math.toRadians(Cesium.Math.toDegrees(viewer.scene.camera.positionCartographic.longitude) + 0.000001);
const startLatCamera = Cesium.Math.toRadians(Cesium.Math.toDegrees(viewer.scene.camera.positionCartographic.latitude));

const terrainSamplePositionsCamera = [];
for (let i = 0; i < length; ++i) {
  const lonLCamera = Cesium.Math.lerp(
    endLonCamera,
	 startLonCamera,
	 i / (length - 1)
  );
  const positionCamera = new Cesium.Cartographic(lonLCamera, startLatCamera);
  terrainSamplePositionsCamera.push(positionCamera);
  }

Promise.resolve(
  Cesium.sampleTerrainMostDetailed(
    viewer.terrainProvider,
	 terrainSamplePositionsCamera
  )
  ).then(function (samples) {
 let terrain_height = samples[0].height;
 let camera_height = viewer.scene.camera.positionCartographic.height;

 //Determine terrain relative height (edist)
 let edist = camera_height - terrain_height;
  //console.log(camera_height + " " + terrain_height)
 //Unburrow code
 if (edist - altOffset < 50) {
    altOffset = 50
	//viewer.scene.camera.moveUp(150 + edist)
 } else {
    altOffset = 0;
  }
});

         setTimeout(a,refreshRate);
	 /*
    viewer.camera.flyTo({
      destination : Cesium.Cartesian3.fromDegrees(lon, lat, alt + 60),
      duration: 2,
      orientation : {
        heading : Cesium.Math.toRadians(azimuth),
        pitch : Cesium.Math.toRadians(-5.0),
      },
      easingFunction: easing_function,
      complete: camera_complete
      });*/
                }
					function process_gpxbase64(msg) {
	  viewer.dataSources
	            .add(
					  Cesium.GpxDataSource.load(
                                            msg,
						 {
						   clampToGround: true,
							}
						))
	  }

let el = new MainWSQueueElement({
msg: 'getgpxbase64'
}, function(msg) {
if (msg.msg === 'R_getgpxbase64') {
return msg.content;
}
return null;
}, 15000, 3);
el.enqueue().then(process_gpxbase64).catch(function(err) {
console.error('Error is ' + err);
});
      setTimeout(a,0);
    </script>
  </body>
</html>
