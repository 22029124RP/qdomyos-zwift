#pragma once

#include <bluetoothdevice.h>
#include <QStringList>
#include <vector>
#include <memory>
#include "discovereddevice.h"
#include "devicediscoveryinfo.h"


class BluetoothDeviceTestData  {
    std::vector<std::shared_ptr<BluetoothDeviceTestData>> exclusions;
    QStringList deviceNames;
    QStringList invalidDeviceNames;
    bool exclusionsConfigured = false;
    bool configuringExclusions = false;
protected:
    enum comparison : int {
        Exact = 0,
        IgnoreCase = 1,
        StartsWith = 2,
        StartsWithIgnoreCase = IgnoreCase+StartsWith
    };

    /**
     * @brief Indicates if there are settings to test. I.e. if a device can be switched off in the settings,
     * test that the device isn't detected if it's disabled.
     */
    bool hasSettings=false;

    /**
     * @brief Indicates if invalid bluetooth device info should be tested for.
     */
    bool testInvalidBluetoothDeviceInfo = false;

    /**
     * @brief Call exclude(...) to populate the exclusions vector. This vector is populated on demand
     * to avoid circularities in the constructors.
     */
    virtual void configureExclusions() {}

    void exclude(BluetoothDeviceTestData* testData);

    /**
     * @brief Add a device name that should be identified as this device.
     * @param deviceName
     * @param length The expected length. Use 0 for unrestricted.
     */
    void addDeviceName(const QString& deviceName, comparison cmp, uint8_t length=0);

    /**
     * @brief Add a device name as a prefix and suffix that should be identified as this device.
     * @param deviceName
     */
    void addDeviceName(const QString& deviceNameStartsWith, const QString& deviceNameEndsWith, comparison cmp);

    /**
     * @brief Add a device name that should NOT be identified as this device.
     * @param deviceName
     */
    void addInvalidDeviceName(const QString& deviceName, comparison cmp);

    /**
     * @brief Add the specified device names with different casings.
     * @param names
     * @param target
     */
    static void addDifferentCasings(const QStringList &names, QStringList &target);
public:
    BluetoothDeviceTestData() {
        // You can do set-up work for each test here.
    }
    virtual ~BluetoothDeviceTestData() {}


    /**
     * @brief A list of bluetooth device names that should be recognised as this device.
     */
    virtual QStringList get_deviceNames() const;

    /**
     * @brief A list of bluetooth device names that should NOT be recognised as this device.
     * By default this is generated by modifying the result of get_deviceNames().
     */
    virtual QStringList get_failingDeviceNames() const;

    /**
     * @brief Gets a list of BluetoothDeviceTestData objects for devices whose
     * prior detection should prevent the detection of this device when an expected device name is found.
     * @return
     */
    virtual std::vector<std::shared_ptr<BluetoothDeviceTestData>> get_exclusions();

    /**
     * @brief Configure the devicediscoveryinfo object to either enable or disable the device.
     * @param info
     * @param enable
     */
    virtual void configureSettings(devicediscoveryinfo& info, bool enable) const {}

    /**
     * @brief Gets the expected device type enumeration value to be detected for this device.
     */
    virtual deviceType get_expectedDeviceType() const =0;

    /**
     * @brief Determines if the specified bluetoothdevice* object is of the expected type for this device.
     * @param detectedDevice
     * @return
     */
    virtual bool get_isExpectedDevice(bluetoothdevice * detectedDevice) const =0;

    /**
     * @brief Indicates if the device has settings that should be considered in the testing.
     */
    bool get_hasSettings() const { return this->hasSettings; }

    /**
     * @brief Indicates if invliad bluetooth device info should be tested for.
     * @return
     */
    bool get_testInvalidBluetoothDeviceInfo() const { return this->testInvalidBluetoothDeviceInfo; }

    /**
     * @brief Specifies a test IP address for wifi devices.
     */
    virtual QString get_testIP() const { return "1.2.3.4"; }


    /**
     * @brief Gets a QBluetoothDeviceInfo object for the specified name and UUID. Can be used to
     * generate invalid objects where device identification relies on more than just the name.
     * @param uuid
     * @param name
     * @param valid
     */
    virtual QBluetoothDeviceInfo get_bluetoothDeviceInfo(const QBluetoothUuid& uuid, const QString& name, bool valid=true) {
        if(!valid)
            throw "Invalid bluetooth device info is not implemented in this class.";
        return QBluetoothDeviceInfo(uuid, name, 0);
    }

};


